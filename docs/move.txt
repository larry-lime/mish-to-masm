# Visibility Modifiers

Every module member has a visibility. By default, all module members are _private_ - meaning they
are only accessible within the module they are defined in. However, you can add a visibility
modifier to make a module member _public_ - visible outside the module, or _public(package)_ -
visible in the modules within the same package, or _entry_ - can be called from a transaction but
can't be called from other modules.

## Internal Visibility

A function or a struct defined in a module which has no visibility modifier is _private_ to the
module. It can't be called from other modules.

```move
module book::internal_visibility {
    // This function can be called from other functions in the same module
    fun internal() { /* ... */ }

    // Same module -> can call internal()
    fun call_internal() {
        internal();
    }
}
```

<!-- Move compiler won't allow this code to compile: -->

<!-- TODO: add failure flag to example -->

```move
module book::try_calling_internal {
    use book::internal_visibility;

    // Different module -> can't call internal()
    fun try_calling_internal() {
        internal_visibility::internal();
    }
}
```

## Public Visibility

A struct or a function can be made _public_ by adding the `public` keyword before the `fun` or
`struct` keyword.

```move
module book::public_visibility {
    // This function can be called from other modules
    public fun public() { /* ... */ }
}
```

A public function can be imported and called from other modules. The following code will compile:

```move
module book::try_calling_public {
    use book::public_visibility;

    // Different module -> can call public()
    fun try_calling_public() {
        public_visibility::public();
    }
}
```

## Package Visibility

Move 2024 introduces the _package visibility_ modifier. A function with _package visibility_ can be
called from any module within the same package. It can't be called from other packages.

```move
module book::package_visibility {
    public(package) fun package_only() { /* ... */ }
}
```

A package function can be called from any module within the same package:

```move
module book::try_calling_package {
    use book::package_visibility;

    // Same package `book` -> can call package_only()
    fun try_calling_package() {
        package_visibility::package_only();
    }
}
```
# Aborting Execution

<!-- Consider "aborting execution" -->

<!--

Chapter: Basic Syntax
Goal: Introduce abort keyword and `assert!` macro.
Notes:
    - previous chapter mentions constants
    - error constants standard ECamelCase
    - `assert!` macro
    - asserts should go before the main logic
    - Move has no catch mechanism
    - abort codes are local to the module
    - there are no error messages emitted
    - error codes should handle all possible scenarios in this module

Links:
    - constants (previous section)
 -->

A transaction can either succeed or fail. Successful execution applies all the changes made to
objects and on-chain data, and the transaction is committed to the blockchain. Alternatively, if a
transaction aborts, the changes are not applied. The `abort` keyword is used to abort a transaction
and revert the changes made so far.

> It is important to note that there is no catch mechanism in Move. If a transaction aborts, the
> changes made so far are reverted, and the transaction is considered failed.

## Abort

The `abort` keyword is used to abort the execution of a transaction. It is used in combination with
an abort code, which will be returned to the caller of the transaction. The abort code is an
[integer](./primitive-types.md) of type `u64`.

```move
{{#include ../../../packages/samples/sources/move-basics/assert-and-abort.move:abort}}
```

The code above will, of course, abort with abort code `1`.

## assert!

The `assert!` macro is a built-in macro that can be used to assert a condition. If the condition is
false, the transaction will abort with the given abort code. The `assert!` macro is a convenient way
to abort a transaction if a condition is not met. The macro shortens the code otherwise written with
an `if` expression + `abort`. The `code` argument is required and has to be a `u64` value.

```move
{{#include ../../../packages/samples/sources/move-basics/assert-and-abort.move:assert}}
```

## Error constants

To make error codes more descriptive, it is a good practice to define
[error constants](./constants.md). Error constants are defined as `const` declarations and are
usually prefixed with `E` followed by a camel case name. Error constants are no different from other
constants and don't have special handling, however, they are used to increase the readability of the
code and make it easier to understand the abort scenarios.

```move
{{#include ../../../packages/samples/sources/move-basics/assert-and-abort.move:error_const}}
```

## Further reading

- [Abort and Assert](/reference/abort-and-assert.html) in the Move Reference.
- We suggest reading the [Better Error Handling](./../guides/better-error-handling.md) guide to
  learn about best practices for error handling in Move.
# Type Reflection

In programming languages _reflection_ is the ability of a program to examine and modify its own
structure and behavior. In Move, there's a limited form of reflection that allows you to inspect the
type of a value at runtime. This is useful when you need to store type information in a homogeneous
collection, or when you need to check if a type belongs to a package.

Type reflection is implemented in the [Standard Library](./standard-library.md) module
`std::type_name`. Expressed very roughly, it gives a single function `get<T>()` which returns the
name of the type `T`.

## In practice

The module is pretty straightforward, and operations allowed on the result are limited to getting a
string representation and extracting the module and address of the type.

```move
{{#include ../../../packages/samples/sources/move-basics/type-reflection.move:main}}
```

## Further reading

Type reflection is an important part of the language, and it is a crucial part of some of the more
advanced patterns.
# Ownership and Scope

Every variable in Move has a scope and an owner. The scope is the range of code where the variable
is valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the
variable is dropped. This is a fundamental concept in Move, and it is important to understand how it
works.

<!--

- Borrow Checker
- Mention Rust's borrow checker
- Borrowing / References intro

-->

## Ownership

A variable defined in a function scope is owned by this scope. The runtime goes through the function
scope and executes every expression and statement. Once the function scope end, the variables
defined in it are dropped or deallocated.

```move
module book::ownership {
    public fun owner() {
        let a = 1; // a is owned by the `owner` function
    } // a is dropped here

    public fun other() {
        let b = 2; // b is owned by the `other` function
    } // b is dropped here

    #[test]
    fun test_owner() {
        owner();
        other();
        // a & b is not valid here
    }
}
```

In the example above, the variable `a` is owned by the `owner` function, and the variable `b` is
owned by the `other` function. When each of these functions are called, the variables are defined,
and when the function ends, the variables are discarded.

## Returning a Value

If we changed the `owner` function to return the variable `a`, then the ownership of `a` would be
transferred to the caller of the function.

```move
module book::ownership {
    public fun owner(): u8 {
        let a = 1; // a defined here
        a // scope ends, a is returned
    }

    #[test]
    fun test_owner() {
        let a = owner();
        // a is valid here
    } // a is dropped here
}
```

## Passing by Value

Additionally, if we passed the variable `a` to another function, the ownership of `a` would be
transferred to this function. When performing this operation, we _move_ the value from one scope to
another. This is also called _move semantics_.

```move
module book::ownership {
    public fun owner(): u8 {
        let a = 10;
        a
    } // a is returned

    public fun take_ownership(v: u8) {
        // v is owned by `take_ownership`
    } // v is dropped here

    #[test]
    fun test_owner() {
        let a = owner();
        take_ownership(a);
        // a is not valid here
    }
}
```

## Scopes with Blocks

Each function has a main scope, and it can also have sub-scopes via the use of blocks. A block is a
sequence of statements and expressions, and it has its own scope. Variables defined in a block are
owned by this block, and when the block ends, the variables are dropped.

```move
module book::ownership {
    public fun owner() {
        let a = 1; // a is owned by the `owner` function's scope
        {
            let b = 2; // b is owned by the block
            {
                let c = 3; // c is owned by the block
            }; // c is dropped here
        }; // b is dropped here
        // a = b; // error: b is not valid here
        // a = c; // error: c is not valid here
    } // a is dropped here
}
```

However, shall we use the return value of a block, the ownership of the variable is transferred to
the caller of the block.

```move
module book::ownership {
    public fun owner(): u8 {
        let a = 1; // a is owned by the `owner` function's scope
        let b = {
            let c = 2; // c is owned by the block
            c // c is returned
        }; // c is dropped here
        a + b // both a and b are valid here
    }
}
```

## Copyable Types

Some types in Move are _copyable_, which means that they can be copied without transferring the
ownership. This is useful for types that are small and cheap to copy, such as integers and booleans.
Move compiler will automatically copy these types when they are passed to a function or returned
from a function, or when they're _moved_ to a scope and then accessed in their original scope.

## Further reading

- [Local Variables and Scopes](/reference/variables.html) in the Move Reference.
# Primitive Types

<!-- TODO: Shall we split this into two pages? Maybe give an overview and focus more on specifics? -->

For simple values, Move has a number of built-in primitive types. They're the base that makes up all
other types. The primitive types are:

- [Booleans](#booleans)
- [Unsigned Integers](#integers)
- [Address](./address.md) - covered in the next section

However, before we get to the types, let's first look at how to declare and assign variables in
Move.

## Variables and assignment

Variables are declared using the `let` keyword. They are immutable by default, but can be made
mutable using the `let mut` keyword. The syntax for the `let mut` statement is:

```
let <variable_name>[: <type>]  = <expression>;
let mut <variable_name>[: <type>] = <expression>;
```

Where:

- `<variable_name>` - the name of the variable
- `<type>` - the type of the variable, optional
- `<expression>` - the value to be assigned to the variable

```move
{{#include ../../../packages/samples/sources/move-basics/primitive-types.move:variables_and_assignment}}
```

A mutable variable can be reassigned using the `=` operator.

```move
y = 43;
```

Variables can also be shadowed by re-declaring.

```move
{{#include ../../../packages/samples/sources/move-basics/primitive-types.move:shadowing}}
```

## Booleans

The `bool` type represents a boolean value - yes or no, true or false. It has two possible values:
`true` and `false` which are keywords in Move. For booleans, there's no need to explicitly specify
the type - the compiler can infer it from the value.

```move
{{#include ../../../packages/samples/sources/move-basics/primitive-types.move:boolean}}
```

Booleans are often used to store flags and to control the flow of the program. Please, refer to the
[Control Flow](./control-flow.md) section for more information.

## Integer Types

Move supports unsigned integers of various sizes: from 8-bit to 256-bit. The integer types are:

- `u8` - 8-bit
- `u16` - 16-bit
- `u32` - 32-bit
- `u64` - 64-bit
- `u128` - 128-bit
- `u256` - 256-bit

```move
{{#include ../../../packages/samples/sources/move-basics/primitive-types.move:integers}}
```

Unlike booleans, integer types need to be inferred. In most of the cases, the compiler will infer
the type from the value, usually defaulting to `u64`. However, sometimes the compiler is unable to
infer the type and will require an explicit type annotation. It can either be provided during
assignment or by using a type suffix.

```move
{{#include ../../../packages/samples/sources/move-basics/primitive-types.move:integer_explicit_type}}
```

### Operations

Move supports the standard arithmetic operations for integers: addition, subtraction,
multiplication, division, and remainder. The syntax for these operations is:

| Syntax | Operation           | Aborts If                                |
| ------ | ------------------- | ---------------------------------------- |
| +      | addition            | Result is too large for the integer type |
| -      | subtraction         | Result is less than zero                 |
| \*     | multiplication      | Result is too large for the integer type |
| %      | modular division    | The divisor is 0                         |
| /      | truncating division | The divisor is 0                         |

> For more operations, including bitwise operations, please refer to the
> [Move Reference](/reference/primitive-types/integers.html#bitwise).

The type of the operands _must match_, otherwise, the compiler will raise an error. The result of
the operation will be of the same type as the operands. To perform operations on different types,
the operands need to be cast to the same type.

<!-- TODO: add examples + parentheses for arithmetic operations -->
<!-- TODO: add bitwise operators -->

### Casting with `as`

Move supports explicit casting between integer types. The syntax for it is:

```move
<expression> as <type>
```

Note, that it may require parentheses around the expression to prevent ambiguity.

```move
{{#include ../../../packages/samples/sources/move-basics/primitive-types.move:cast_as}}
```

A more complex example, preventing overflow:

```move
{{#include ../../../packages/samples/sources/move-basics/primitive-types.move:overflow}}
```

### Overflow

Move does not support overflow / underflow, an operation that results in a value outside the range
of the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.

```move
let x = 255u8;
let y = 1u8;

// This will raise an error
let z = x + y;
```

## Further reading

- [Bool](/reference/primitive-types/bool.html) in the Move Reference.
- [Integer](/reference/primitive-types/integers.html) in the Move Reference.
# Struct Methods

Move Compiler supports _receiver syntax_, which allows defining methods which can be called on
instances of a struct. This is similar to the method syntax in other programming languages. It is a
convenient way to define functions which operate on the fields of a struct.

## Method syntax

If the first argument of a function is a struct internal to the module, then the function can be
called using the `.` operator. If the function uses a struct from another module, then method won't
be associated with the struct by default. In this case, the function can be called using the
standard function call syntax.

When a module is imported, the methods are automatically associated with the struct.

```move
{{#include ../../../packages/samples/sources/move-basics/struct-methods.move:hero}}
```

## Method Aliases

For modules that define multiple structs and their methods, it is possible to define method aliases
to avoid name conflicts, or to provide a better-named method for a struct.

The syntax for aliases is:

```move
// for local method association
use fun function_path as Type.method_name;

// exported alias
public use fun function_path as Type.method_name;
```

> Public aliases are only allowed for structs defined in the same module. If a struct is defined in
> another module, an alias can still be created but cannot be made public.

In the example below, we changed the `hero` module and added another type - `Villain`. Both `Hero`
and `Villain` have similar field names and methods. And to avoid name conflicts, we prefixed methods
with `hero_` and `villain_` respectively. However, we can create aliases for these methods so that
they can be called on the instances of the structs without the prefix.

```move
{{#include ../../../packages/samples/sources/move-basics/struct-methods.move:hero_and_villain}}
```

As you can see, in the test function, we called the `health` method on the instances of `Hero` and
`Villain` without the prefix. The compiler will automatically associate the methods with the
structs.

## Aliasing an external module's method

It is also possible to associate a function defined in another module with a struct from the current
module. Following the same approach, we can create an alias for the method defined in another
module. Let's use the `bcs::to_bytes` method from the [Standard Library](./standard-library.md) and
associate it with the `Hero` struct. It will allow serializing the `Hero` struct to a vector of
bytes.

```move
{{#include ../../../packages/samples/sources/move-basics/struct-methods.move:hero_to_bytes}}
```

## Further reading

- [Method Syntax](/reference/method-syntax.html) in the Move Reference.
# Abilities: Introduction

Move has a unique type system which allows customizing _type abilities_.
[In the previous section](./struct.md), we introduced the `struct` definition and how to use it.
However, the instances of the `Artist` and `Record` structs had to be unpacked for the code to
compile. This is default behavior of a struct without _abilities_.

> Throughout the book you will see chapters with name `Ability: <name>`, where `<name>` is the name
> of the ability. These chapters will cover the ability in detail, how it works, and how to use it
> in Move.

## What are Abilities?

Abilities are a way to allow certain behaviors for a type. They are a part of the struct declaration
and define which behaviours are allowed for the instances of the struct.

## Abilities syntax

Abilities are set in the struct definition using the `has` keyword followed by a list of abilities.
The abilities are separated by commas. Move supports 4 abilities: `copy`, `drop`, `key`, and
`store`, each of them is used to define a specific behaviour for the struct instances.

```move
/// This struct has the `copy` and `drop` abilities.
struct VeryAble has copy, drop {
    // field: Type1,
    // field2: Type2,
    // ...
}
```

## Overview

A quick overview of the abilities:

> All of the built-in types, except references, have `copy`, `drop` and `store` abilities.
> References have `copy` and `drop`.

- `copy` - allows the struct to be _copied_. Explained in the [Ability: Copy](./copy-ability.md)
  chapter.
- `drop` - allows the struct to be _dropped_ or _discarded_. Explained in the
  [Ability: Drop](./drop-ability.md) chapter.
- `key` - allows the struct to be used as a _key_ in a storage. Explained in the
  [Ability: Key](./../storage/key-ability.md) chapter.
- `store` - allows the struct to be _stored_ in structs with the _key_ ability. Explained in the
  [Ability: Store](./../storage/store-ability.md) chapter.

While it is important to mention them here, we will go in detail about each ability in the following
chapters and give a proper context on how to use them.

## No abilities

A struct without abilities cannot be discarded, or copied, or stored in the storage. We call such a
struct a _Hot Potato_. It is a joke, but it is also a good way to remember that a struct without
abilities is like a hot potato - it can only be passed around and requires special handling. Hot
Potato is one of the most powerful patterns in Move, we go in detail about it in the
[Hot Potato](./../programmability/hot-potato.md) chapter.

## Further reading

- [Type Abilities](/reference/type-abilities.html) in the Move Reference.
# Abilities: Drop

<!-- TODO: reiterate, given that we introduce abilities one by one -->

<!-- TODO:

- introduce abilities first
- mention them all
- then do one by one

consistency: we / I / you ?
who is we? I am alone, there's no one else here


-->

<!--

// Shall we only talk about `drop` ?
// So that we don't explain scopes and `copy` / `move` semantics just yet?

Chapter: Basic Syntax
Goal: Introduce Copy and Drop abilities of Move. Follows the `struct` section
Notes:
    - compare them to primitive types introduces before;
    - what is an ability without drop
    - drop is not necessary for unpacking
    - make a joke about a bacteria pattern in the code
    - mention that a struct with only `drop` ability is called a Witness
    - mention that a struct without abilities is called a Hot Potato
    - mention that there are two more abilities which are covered in a later chapter

Links:
    - language reference (abilities)
    - authorization patterns (or witness)
    - hot potato pattern
    - key and store abilities (later chapter)

 -->

The `drop` ability - the simplest of them - allows the instance of a struct to be _ignored_ or
_discarded_. In many programming languages this behavior is considered default. However, in Move, a
struct without the `drop` ability is not allowed to be ignored. This is a safety feature of the Move
language, which ensures that all assets are properly handled. An attempt to ignore a struct without
the `drop` ability will result in a compilation error.

```move
{{#include ../../../packages/samples/sources/move-basics/drop-ability.move:main}}
```

The `drop` ability is often used on custom collection types to eliminate the need for special
handling of the collection when it is no longer needed. For example, a `vector` type has the `drop`
ability, which allows the vector to be ignored when it is no longer needed. However, the biggest
feature of Move's type system is the ability to not have `drop`. This ensures that the assets are
properly handled and not ignored.

A struct with a single `drop` ability is called a _Witness_. We explain the concept of a _Witness_
in the
[Witness and Abstract Implementation](./../programmability/witness-and-abstract-implementation.md)
section.

## Types with the `drop` Ability

All native types in Move have the `drop` ability. This includes:

- [bool](./../move-basics/primitive-types.md#booleans)
- [unsigned integers](./../move-basics/primitive-types.md#integers)
- [vector](./../move-basics/vector.md)
- [address](./../move-basics/address.md)

All of the types defined in the standard library have the `drop` ability as well. This includes:

- [Option](./../move-basics/option.md)
- [String](./../move-basics/string.md)
- [TypeName](./../move-basics/type-reflection.md#typename)

## Further reading

- [Type Abilities](/reference/type-abilities.html) in the Move Reference.
# Generics

Generics are a way to define a type or function that can work with any type. This is useful when you
want to write a function which can be used with different types, or when you want to define a type
that can hold any other type. Generics are the foundation of many advanced features in Move, such as
collections, abstract implementations, and more.

## In the Standard Library

In this chapter we already mentioned the [vector](./vector.md) type, which is a generic type that
can hold any other type. Another example of a generic type in the standard library is the
[Option](./option.md) type, which is used to represent a value that may or may not be present.

## Generic Syntax

To define a generic type or function, a type signature needs to have a list of generic parameters
enclosed in angle brackets (`<` and `>`). The generic parameters are separated by commas.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:container}}
```

In the example above, `Container` is a generic type with a single type parameter `T`, the `value`
field of the container stores the `T`. The `new` function is a generic function with a single type
parameter `T`, and it returns a `Container` with the given value. Generic types must be initialed
with a concrete type, and generic functions must be called with a concrete type.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:test_container}}
```

In the test function `test_generic` we demonstrate three equivalent ways to create a new `Container`
with a `u8` value. Because numeric types need to be inferred, we specify the type of the number
literal.

## Multiple Type Parameters

You can define a type or function with multiple type parameters. The type parameters are then
separated by commas.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:pair}}
```

In the example above, `Pair` is a generic type with two type parameters `T` and `U`, and the
`new_pair` function is a generic function with two type parameters `T` and `U`. The function returns
a `Pair` with the given values. The order of the type parameters is important, and it should match
the order of the type parameters in the type signature.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:test_pair}}
```

If we added another instance where we swapped type parameters in the `new_pair` function, and tried
to compare two types, we'd see that the type signatures are different, and cannot be compared.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:test_pair_swap}}
```

Types for variables `pair1` and `pair2` are different, and the comparison will not compile.

## Why Generics?

In the examples above we focused on instantiating generic types and calling generic functions to
create instances of these types. However, the real power of generics is the ability to define shared
behavior for the base, generic type, and then use it independently of the concrete types. This is
especially useful when working with collections, abstract implementations, and other advanced
features in Move.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:user}}
```

In the example above, `User` is a generic type with a single type parameter `T`, with shared fields
`name` and `age`, and the generic `metadata` field which can store any type. No matter what the
`metadata` is, all of the instances of `User` will have the same fields and methods.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:update_user}}
```

## Phantom Type Parameters

In some cases, you may want to define a generic type with a type parameter that is not used in the
fields or methods of the type. This is called a _phantom type parameter_. Phantom type parameters
are useful when you want to define a type that can hold any other type, but you want to enforce some
constraints on the type parameter.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:phantom}}
```

The `Coin` type here does not contain any fields or methods that use the type parameter `T`. It is
used to differentiate between different types of coins, and to enforce some constraints on the type
parameter `T`.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:test_phantom}}
```

In the example above, we demonstrate how to create two different instances of `Coin` with different
phantom type parameters `USD` and `EUR`. The type parameter `T` is not used in the fields or methods
of the `Coin` type, but it is used to differentiate between different types of coins. It will make
sure that the `USD` and `EUR` coins are not mixed up.

## Constraints on Type Parameters

Type parameters can be constrained to have certain abilities. This is useful when you need the inner
type to allow certain behavior, such as _copy_ or _drop_. The syntax for constraining a type
parameter is `T: <ability> + <ability>`.

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:constraints}}
```

Move Compiler will enforce that the type parameter `T` has the specified abilities. If the type
parameter does not have the specified abilities, the code will not compile.

<!-- TODO: failure case -->

```move
{{#include ../../../packages/samples/sources/move-basics/generics.move:test_constraints}}
```

## Further Reading

- [Generics](/reference/generics.html) in the Move Reference.
# Standard Library

<!-- The Move standard library provides a set of modules  -->

The Move Standard Library provides functionality for native types and operations. It is a standard
collection of modules which do not interact with the storage, but provide basic tools for working
and manipulating the data. It is the only dependency of the
[Sui Framework](../programmability/sui-framework.md), and is imported together with it.

## Most Common Modules

In this book we go into detail about most of the modules in the Standard Library, however, it is
also helpful to give an overview of the features, so that you can get a sense of what is available
and which module implements it.

<!-- Custom CSS addition in the theme/custom.css  -->
<div class="modules-table">

| Module                                                                           | Description                                                                | Chapter                                                                    |
| -------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| [std::string](https://docs.sui.io/references/framework/move-stdlib/string)       | Provides basic string operations                                           | [String](./string.md)                                                      |
| [std::ascii](https://docs.sui.io/references/framework/move-stdlib/ascii)         | Provides basic ASCII operations                                            | [String](./string.md)                                                      |
| [std::option](https://docs.sui.io/references/framework/move-stdlib/option)       | Implements an `Option<T>`                                                  | [Option](./option.md)                                                      |
| [std::vector](https://docs.sui.io/references/framework/move-stdlib/vector)       | Native operations on the vector type                                       | [Vector](./vector.md)                                                      |
| [std::bcs](https://docs.sui.io/references/framework/move-stdlib/bcs)             | Contains the `bcs::to_bytes()` function                                    | [BCS](../move-basics/bcs.md)                                               |
| [std::address](https://docs.sui.io/references/framework/move-stdlib/address)     | Contains a single `address::length` function                               | [Address](./address.md)                                                    |
| [std::type_name](https://docs.sui.io/references/framework/move-stdlib/type_name) | Allows runtime _type reflection_                                           | [Type Reflection](./type-reflection.md)                                    |
| std::hash                                                                        | Hashing functions: `sha2_256` and `sha3_256`                               | [Cryptography and Hashing](../programmability/cryptography-and-hashing.md) |
| std::debug                                                                       | Contains debugging functions, which are available in only in **test** mode | [Debugging](./debugging.md)                                                |
| std::bit_vector                                                                  | Provides operations on bit vectors                                         | -                                                                          |
| std::fixed_point32                                                               | Provides the `FixedPoint32` type                                           | -                                                                          |

</div>

## Exported Addresses

Standard Library exports one named address - `std = 0x1`.

```toml
[addresses]
std = "0x1"
```

## Implicit Imports

Some of the modules are imported implicitly, and are available in the module without explicit `use`
import. For Standard Library, these modules and types are:

- std::vector
- std::option
- std::option::Option

## Importing std without Sui Framework

The Move Standard Library can be imported to the package directly. However, `std` alone is not
enough to build a meaningful application, as it does not provide any storage capabilities, and can't
interact with the on-chain state.

```toml
MoveStdlib = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/move-stdlib", rev = "framework/mainnet" }
```

## Source Code

The source code of the Move Standard Library is available in the
[Sui repository](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/move-stdlib/sources).
# Expression

In programming languages expression is a unit of code which returns a value, in Move, almost
everything is an expression, - with the sole exception of `let` statement which is a declaration. In
this section, we cover the types of expressions and introduce the concept of scope.

> Expressions are sequenced with semicolons `;`. If there's "no expression" after the semicolon, the
> compiler will insert a unit `()` - an empty expression.

## Literals

In the [Primitive Types](./primitive-types.md) section, we introduced the basic types of Move. And
to illustrate them, we used literals. A literal is a notation for representing a fixed value in the
source code. Literals are used to initialize variables and to pass arguments to functions. Move has
the following literals:

- `true` and `false` for boolean values
- `0`, `1`, `123123` or other numeric for integer values
- `0x0`, `0x1`, `0x123` or other hexadecimal for integer values
- `b"bytes_vector"` for byte vector values
- `x"0A"` HEX literal for byte values

```move
{{#include ../../../packages/samples/sources/move-basics/expression.move:literals}}
```

## Operators

Arithmetic, logical, and bitwise operators are used to perform operations on values. The result of
an operation is a value, so operators are also expressions.

```move
{{#include ../../../packages/samples/sources/move-basics/expression.move:operators}}
```

## Blocks

A block is a sequence of statements and expressions, and it returns the value of the last expression
in the block. A block is written as a pair of curly braces `{}`. A block is an expression, so it can
be used anywhere an expression is expected.

```move
{{#include ../../../packages/samples/sources/move-basics/expression.move:block}}
```

## Function Calls

We go into detail about functions in the [Functions](./functions.md) section. However, we already
used function calls in the previous sections, so it's worth mentioning them here. A function call is
an expression that calls a function and returns the value of the last expression in the function
body.

```move
{{#include ../../../packages/samples/sources/move-basics/expression.move:fun_call}}
```

## Control Flow Expressions

Control flow expressions are used to control the flow of the program. They are also expressions, so
they return a value. We cover control flow expressions in the [Control Flow](./control-flow.md)
section. Here's a very brief overview:

```move
{{#include ../../../packages/samples/sources/move-basics/expression.move:control_flow}}
```
# Comments

<!--

Chapter: Basic Syntax
Goal: Introduce comments.
Notes:
    - doc comments are used in docgen
    - only public members are documented
    - doc comments are placed in between attributes and the definition
    - doc comments are allowed for: modules, structs, functions, constants
    - give an example of how doc comments are translated
 -->

Comments are a way to add notes or document your code. They are ignored by the compiler and don't
result in the Move bytecode. You can use comments to explain what your code does, to add notes to
yourself or other developers, to temporarily remove a part of your code, or to generate
documentation. There are three types of comments in Move: line comment, block comment, and doc
comment.

## Line comment

```Move
{{#include ../../../packages/samples/sources/move-basics/comments.move:line}}
```

You can use double slash `//` to comment out the rest of the line. Everything after `//` will be
ignored by the compiler.

```Move
{{#include ../../../packages/samples/sources/move-basics/comments.move:line_2}}
```

## Block comment

Block comments are used to comment out a block of code. They start with `/*` and end with `*/`.
Everything between `/*` and `*/` will be ignored by the compiler. You can use block comments to
comment out a single line or multiple lines. You can even use them to comment out a part of a line.

```Move
{{#include ../../../packages/samples/sources/move-basics/comments.move:block}}
```

This example is a bit extreme, but it shows how you can use block comments to comment out a part of
a line.

## Doc comment

Documentation comments are special comments that are used to generate documentation for your code.
They are similar to block comments, but they start with three slashes `///` and are placed before
the definition of the item they document.

```Move
{{#include ../../../packages/samples/sources/move-basics/comments.move:doc}}
```

<!-- TODO: docgen, which members are in the documentation -->
# Custom Types with Struct

Move's type system shines when it comes to defining custom types. User defined types can be custom
tailored to the specific needs of the application. Not just on the data level, but also in its
behavior. In this section we introduce the struct definition and how to use it.

## Struct

To define a custom type, you can use the `struct` keyword followed by the name of the type. After
the name, you can define the fields of the struct. Each field is defined with the
`field_name: field_type` syntax. Field definitions must be separated by commas. The fields can be of
any type, including other structs.

> Move does not support recursive structs, meaning a struct cannot contain itself as a field.

```move
{{#include ../../../packages/samples/sources/move-basics/struct.move:def}}
```

In the example above, we define a `Record` struct with five fields. The `title` field is of type
`String`, the `artist` field is of type `Artist`, the `year` field is of type `u16`, the `is_debut`
field is of type `bool`, and the `edition` field is of type `Option<u16>`. The `edition` field is of
type `Option<u16>` to represent that the edition is optional.

Structs are private by default, meaning they cannot be imported and used outside of the module they
are defined in. Their fields are also private and can't be accessed from outside the module. See
[visibility](./visibility.md) for more information on different visibility modifiers.

> Fields of a struct are private and can only be accessed by the module defining the struct. Reading
> and writing the fields of a struct in other modules is only possible if the module defining the
> struct provides public functions to access the fields.

## Create and use an instance

We described how struct _definition_ works. Now let's see how to initialize a struct and use it. A
struct can be initialized using the `struct_name { field1: value1, field2: value2, ... }` syntax.
The fields can be initialized in any order, and all of the fields must be set.

```move
{{#include ../../../packages/samples/sources/move-basics/struct.move:pack}}
```

In the example above, we create an instance of the `Artist` struct and set the `name` field to a
string "The Beatles".

To access the fields of a struct, you can use the `.` operator followed by the field name.

```move
{{#include ../../../packages/samples/sources/move-basics/struct.move:access}}
```

Only module defining the struct can access its fields (both mutably and immutably). So the above
code should be in the same module as the `Artist` struct.

<!-- ## Accessing Fields

Struct fields are private and can be accessed only by the module defining the struct. To access the fields of a struct, you can use the `.` operator followed by the field name.

```move
# anchor: access
{{#include ../../../packages/samples/sources/move-basics/struct.move:access}}
```
-->

## Unpacking a struct

Structs are non-discardable by default, meaning that the initiated struct value must be used: either
stored or _unpacked_. Unpacking a struct means deconstructing it into its fields. This is done using
the `let` keyword followed by the struct name and the field names.

```move
{{#include ../../../packages/samples/sources/move-basics/struct.move:unpack}}
```

In the example above we unpack the `Artist` struct and create a new variable `name` with the value
of the `name` field. Because the variable is not used, the compiler will raise a warning. To
suppress the warning, you can use the underscore `_` to indicate that the variable is intentionally
unused.

```move
{{#include ../../../packages/samples/sources/move-basics/struct.move:unpack_ignore}}
```

## Further reading

- [Structs](/reference/structs.html) in the Move Reference.
# Function

Functions are the building blocks of Move programs. They are called from
[user transactions](../concepts/user-interaction.md) and from other functions and group executable
code into reusable units. Functions can take arguments and return a value. They are declared with
the `fun` keyword at the module level. Just like any other module member, by default they're private
and can only be accessed from within the module.

```move
{{#include ../../../packages/samples/sources/move-basics/function.move:math}}
```

In this example, we define a function `add` that takes two arguments of type `u64` and returns their
sum. The function is called from the `test_add` function, which is a test function located in the
same module. In the test we compare the result of the `add` function with the expected value and
abort the execution if the result is different.

## Function declaration

> There's a convention to call functions in Move with the `snake_case` naming convention. This means
> that the function name should be all lowercase with words separated by underscores. For example,
> `do_something`, `add`, `get_balance`, `is_authorized`, and so on.

A function is declared with the `fun` keyword followed by the function name (a valid Move
identifier), a list of arguments in parentheses, and a return type. The function body is a block of
code that contains a sequence of statements and expressions. The last expression in the function
body is the return value of the function.

```move
{{#include ../../../packages/samples/sources/move-basics/function.move:return_nothing}}
```

## Accessing functions

Just like any other module member, functions can be imported and accessed via a path. The path
consists of the module path and the function name separated by `::`. For example, if you have a
function called `add` in the `math` module in the `book` package, the path to it will be
`book::math::add`, or, if the module is imported, `math::add`.

```move
{{#include ../../../packages/samples/sources/move-basics/function.move:use_math}}
```

## Multiple return values

Move functions can return multiple values, which is useful when you need to return more than one
value from a function. The return type of the function is a tuple of types. The return value is a
tuple of expressions.

```move
{{#include ../../../packages/samples/sources/move-basics/function.move:tuple_return}}
```

Result of a function call with tuple return has to be unpacked into variables via `let (tuple)`
syntax:

```move
{{#include ../../../packages/samples/sources/move-basics/function.move:tuple_return_imm}}
```

If any of the declared values need to be declared as mutable, the `mut` keyword is placed before the
variable name:

```move
{{#include ../../../packages/samples/sources/move-basics/function.move:tuple_return_mut}}
```

If some of the arguments are not used, they can be ignored with the `_` symbol:

```move
{{#include ../../../packages/samples/sources/move-basics/function.move:tuple_return_ignore}}
```

## Further reading

- [Functions](/reference/functions.html) in the Move Reference.
# String

While Move does not have a built-in type to represent strings, it does have two standard
implementations for strings in the [Standard Library](./standard-library.md). The `std::string`
module defines a `String` type and methods for UTF-8 encoded strings, and the second module,
`std::ascii`, provides an ASCII `String` type and its methods.

> Sui execution environment automatically converts bytevector into `String` in transaction inputs.
> So in many cases, a String does not need to be constructed in the
> [Transaction Block](./../concepts/what-is-a-transaction.md).

<!--

## Bytestring Literal

TODO:

- reference vector
- reference literals - [Expression](./expression.md#literals)

-->

## Strings are bytes

No matter which type of string you use, it is important to know that strings are just bytes. The
wrappers provided by the `string` and `ascii` modules are just that: wrappers. They do provide
safety checks and methods to work with strings, but at the end of the day, they are just vectors of
bytes.

```move
{{#include ../../../packages/samples/sources/move-basics/string.move:custom}}
```

## Working with UTF-8 Strings

While there are two types of strings in the standard library, the `string` module should be
considered the default. It has native implementations of many common operations, and hence is more
efficient than the `ascii` module, which is fully implemented in Move.

### Definition

The `String` type in the `std::string` module is defined as follows:

```move
// File: move-stdlib/sources/string.move
/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.
public struct String has copy, drop, store {
    bytes: vector<u8>,
}
```

### Creating a String

To create a new UTF-8 `String` instance, you can use the `string::utf8` method. The
[Standard Library](./standard-library.md) provides an alias `.to_string()` on the `vector<u8>` for
convenience.

```move
{{#include ../../../packages/samples/sources/move-basics/string.move:utf8}}
```

### Common Operations

UTF8 String provides a number of methods to work with strings. The most common operations on strings
are: concatenation, slicing, and getting the length. Additionally, for custom string operations, the
`bytes()` method can be used to get the underlying byte vector.

```move
let mut str = b"Hello,".to_string();
let another = b" World!".to_string();

// append(String) adds the content to the end of the string
str.append(another);

// `sub_string(start, end)` copies a slice of the string
str.sub_string(0, 5); // "Hello"

// `length()` returns the number of bytes in the string
str.length(); // 12 (bytes)

// methods can also be chained! Get a length of a substring
str.sub_string(0, 5).length(); // 5 (bytes)

// whether the string is empty
str.is_empty(); // false

// get the underlying byte vector for custom operations
let bytes: &vector<u8> = str.bytes();
```

### Safe UTF-8 Operations

The default `utf8` method may abort if the bytes passed into it are not valid UTF-8. If you are not
sure that the bytes you are passing are valid, you should use the `try_utf8` method instead. It
returns an `Option<String>`, which contains no value if the bytes are not valid UTF-8, and a string
otherwise.

> Hint: the name that starts with `try_*` indicates that the function returns an Option with the
> expected result or `none` if the operation fails. It is a common naming convention borrowed from
> Rust.

```move
{{#include ../../../packages/samples/sources/move-basics/string.move:safe_utf8}}
```

### UTF-8 Limitations

The `string` module does not provide a way to access individual characters in a string. This is
because UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to
4 bytes. Similarly, the `length()` method returns the number of bytes in the string, not the number
of characters.

However, methods like `sub_string` and `insert` check character boundaries and will abort when the
index is in the middle of a character.

## ASCII Strings

This section is coming soon!
# Module

<!--

Chapter: Base Syntax
Goal: Introduce module keyword.
Notes:
    - modules are the base unit of code organization
    - module members are private by default
    - types internal to the module have special access rules
    - only module can pack and unpack its types

 -->

Module is the base unit of code organization in Move. Modules are used to group and isolate code,
and all of the members of the module are private to the module by default. In this section you will
learn how to define a module, how to declare its members and how to access them from other modules.

## Module declaration

Modules are declared using the `module` keyword followed by the package address, module name and the
module body inside the curly braces `{}`. The module name should be in `snake_case` - all lowercase
letters with underscores between words. Modules names must be unique in the package.

Usually, a single file in the `sources/` folder contains a single module. The file name should match
the module name - for example, a `donut_shop` module should be stored in the `donut_shop.move` file.
You can read more about coding conventions in the
[Coding Conventions](../special-topics/coding-conventions.md) section.

```Move
{{#include ../../../packages/samples/sources/move-basics/module.move:module}}
```

Structs, functions, constants and imports all part of the module:

- [Structs](./struct.md)
- [Functions](./function.md)
- [Constants](./constants.md)
- [Imports](./importing-modules.md)
- [Struct Methods](./struct-methods.md)

## Address / Named address

Module address can be specified as both: an address _literal_ (does not require the `@` prefix) or a
named address specified in the [Package Manifest](../concepts/manifest.md). In the example below,
both are identical because there's a `book = "0x0"` record in the `[addresses]` section of the
`Move.toml`.

```Move
{{#include ../../../packages/samples/sources/move-basics/module.move:address_literal}}
```

Addresses section in the Move.toml:

```toml
# Move.toml
[addresses]
book = "0x0"
```

## Module members

Module members are declared inside the module body. To illustrate that, let's define a simple module
with a struct, a function and a constant:

```Move
{{#include ../../../packages/samples/sources/move-basics/module.move:members}}
```

## Further reading

- [Modules](/reference/modules.html) in the Move Reference.
# Testing

A crucial part of any software development, and even more - blockchain development, is testing.
Here, we will cover the basics of testing in Move and how to write and organize tests for your Move
code.

## The `#[test]` attribute

Tests in Move are functions marked with the `#[test]` attribute. This attribute tells the compiler
that the function is a test function, and it should be run when the tests are executed. Test
functions are regular functions, but they must take no arguments and have no return value. They
are excluded from the bytecode, and are never published.

```move
module book::testing {
    // Test attribute is placed before the `fun` keyword. Can be both above or
    // right before the `fun` keyword: `#[test] fun my_test() { ... }`
    // The name of the test would be `book::testing::simple_test`.
    #[test]
    fun simple_test() {
        let sum = 2 + 2;
        assert!(sum == 4, 1);
    }

    // The name of the test would be `book::testing::more_advanced_test`.
    #[test] fun more_advanced_test() {
        let sum = 2 + 2 + 2;
        assert!(sum == 4, 1);
    }
}
```

## Running Tests

To run tests, you can use the `sui move test` command. This command will first build the package in
the _test mode_ and then run all the tests found in the package. During test mode, modules from both
`sources/` and `tests/` directories are processed, and the tests are executed.

```bash
$ sui move test
> INCLUDING DEPENDENCY Sui
> INCLUDING DEPENDENCY MoveStdlib
> BUILDING book
> Running Move unit tests
> ...
```

<!-- TODO: fill output -->

## Test Fail Cases with `#[expected_failure]`

Tests for fail cases can be marked with `#[expected_failure]`. This attribute placed on a `#[test]`
function tells the compiler that the test is expected to fail. This is useful when you want to test
that a function fails when a certain condition is met.

> This attribute can only be placed on a `#[test]` function.

The attribute can take an argument for abort code, which is the expected abort code when the test
fails. If the test fails with a different abort code, the test will fail. If the execution did not
abort, the test will also fail.

```move
module book::testing_failure {

    const EInvalidArgument: u64 = 1;

    #[test]
    #[expected_failure(abort_code = 0)]
    fun test_fail() {
        abort 0 // aborts with 0
    }

    // attributes can be grouped together
    #[test, expected_failure(abort_code = EInvalidArgument)]
    fun test_fail_1() {
        abort 1 // aborts with 1
    }
}
```

The `abort_code` argument can use constants defined in the tests module as well as imported from
other modules. This is the only case where constants can be used and "accessed" in other modules.

## Utilities with `#[test_only]`

In some cases, it is helpful to give the test environment access to some of the internal functions
or features. It simplifies the testing process and allows for more thorough testing. However, it is
important to remember that these functions should not be included in the final package. This is
where the `#[test_only]` attribute comes in handy.

```move
module book::testing {
    // Public function which uses the `secret` function.
    public fun multiply_by_secret(x: u64): u64 {
        x * secret()
    }

    /// Private function which is not available to the public.
    fun secret(): u64 { 100 }

    #[test_only]
    /// This function is only available for testing purposes in tests and other
    /// test-only functions. Mind the visibility - for `#[test_only]` it is
    /// common to use `public` visibility.
    public fun secret_for_testing(): u64 {
        secret()
    }

    #[test]
    // In the test environment we have access to the `secret_for_testing` function.
    fun test_multiply_by_secret() {
        let expected = secret_for_testing() * 2;
        assert!(multiply_by_secret(2) == expected, 1);
    }
}
```

Functions marked with the `#[test_only]` will be available to the test environment, and to the other
modules if their visibility is set so.

## Further Reading

- [Unit Testing](https://move-book.com/reference/unit-testing.html) in the Move Reference.
# Abilities: Copy

In Move, the _copy_ ability on a type indicates that the instance or the value of the type can be
copied. While this behavior may feel very natural when working with numbers or other simple types,
it is not the default for custom types in Move. This is because Move is designed to express digital
assets and resources, and inability to copy is a key element of the resource model.

However, Move type system allows you to define custom types with the _copy_ ability.

```move
{{#include ../../../packages/samples/sources/move-basics/copy-ability.move:copyable}}
```

In the example above, we define a custom type `Copyable` with the _copy_ ability. This means that
instances of `Copyable` can be copied, both implicitly and explicitly.

```move
{{#include ../../../packages/samples/sources/move-basics/copy-ability.move:copyable_test}}
```

In the example above, `a` is copied to `b` implicitly, and then explicitly copied to `c` using the
dereference operator. If `Copyable` did not have the _copy_ ability, the code would not compile, and
the Move compiler would raise an error.

## Copying and Drop

The `copy` ability is closely related to [`drop` ability](./drop-ability.md). If a type has the
_copy_ ability, very likely that it should have `drop` too. This is because the _drop_ ability is
required to clean up the resources when the instance is no longer needed. If a type has only _copy_,
then managing its instances gets more complicated, as the values cannot be ignored.

```move
{{#include ../../../packages/samples/sources/move-basics/copy-ability.move:copy_drop}}
```

All of the primitive types in Move behave as if they have the _copy_ and _drop_ abilities. This
means that they can be copied and dropped, and the Move compiler will handle the memory management
for them.

## Types with the `copy` Ability

All native types in Move have the `copy` ability. This includes:

- [bool](./../move-basics/primitive-types.md#booleans)
- [unsigned integers](./../move-basics/primitive-types.md#integers)
- [vector](./../move-basics/vector.md)
- [address](./../move-basics/address.md)

All of the types defined in the standard library have the `copy` ability as well. This includes:

- [Option](./../move-basics/option.md)
- [String](./../move-basics/string.md)
- [TypeName](./../move-basics/type-reflection.md#typename)

## Further reading

- [Type Abilities](/reference/type-abilities.html) in the Move Reference.
# Move Basics

This chapter is all about the basic syntax of the Move language. It covers the basics of the
language, such as types, modules, functions, and control flow. It focuses on the language without a
storage model or a blockchain, and explains the essential concepts of the language. To learn
features specific to Sui, such as storage functions and abilities, refer to the
[Using Objects](../storage/README.md) chapter, however, it is recommended to start with this chapter
first.

<!-- TODO: cross link with Reference -->
# Vector

Vectors are a native way to store collections of elements in Move. They are similar to arrays in
other programming languages, but with a few differences. In this section, we introduce the `vector`
type and its operations.

## Vector syntax

The `vector` type is defined using the `vector` keyword followed by the type of the elements in
angle brackets. The type of the elements can be any valid Move type, including other vectors. Move
has a vector literal syntax that allows you to create vectors using the `vector` keyword followed by
square brackets containing the elements (or no elements for an empty vector).

```move
{{#include ../../../packages/samples/sources/move-basics/vector.move:literal}}
```

The `vector` type is a built-in type in Move, and does not need to be imported from a module.
However, vector operations are defined in the `std::vector` module, and you need to import the
module to use them.

## Vector operations

The standard library provides methods to manipulate vectors. The following are some of the most
commonly used operations:

- `push_back`: Adds an element to the end of the vector.
- `pop_back`: Removes the last element from the vector.
- `length`: Returns the number of elements in the vector.
- `is_empty`: Returns true if the vector is empty.
- `remove`: Removes an element at a given index.

```move
{{#include ../../../packages/samples/sources/move-basics/vector.move:methods}}
```

## Destroying a Vector of non-droppable types

A vector of non-droppable types cannot be discarded. If you define a vector of types without `drop`
ability, the vector value cannot be ignored. However, if the vector is empty, compiler requires an
explicit call to `destroy_empty` function.

```move
{{#include ../../../packages/samples/sources/move-basics/vector.move:no_drop}}
```

## Further reading

- [Vector](/reference/primitive-types/vector.html) in the Move Reference.
# References

<!--

Chapter: Basic Syntax
Goal: Show what the borrow checker is and how it works.
Notes:
    - give the metro pass example
    - show why passing by reference is useful
    - mention that reference comparison is faster
    - references can be both mutable and immutable
    - immutable access to shared objects is faster
    - implicit copy
    - moving the value
    - unpacking a reference (mutable and immutable)

 -->

In the [Ownership and Scope](./ownership-and-scope.md) section, we explained that when a value is
passed to a function, it is _moved_ to the function's scope. This means that the function becomes
the owner of the value, and the original scope (owner) can no longer use it. This is an important
concept in Move, as it ensures that the value is not used in multiple places at the same time.
However, there are use cases when we want to pass a value to a function but retain the ownership.
This is where references come into play.

To illustrate this, let's consider a simple example - an application for a metro (subway) pass. We
will look at 4 different scenarios:

1. Card can be purchased at the kiosk for a fixed price
2. Card can be shown to inspectors to prove that the passenger has a valid pass
3. Card can be used at the turnstile to enter the metro, and spend a ride
4. Card can be recycled once it's empty

## Layout

The initial layout of the metro pass application is simple. We define the `Card` type and the `USES`
[constant](./constants.md) that represents the number of rides for a single card. We also add an
[error constant](./assert-and-abort.md#error-constants) for the case when the card is empty.

```move
module book::metro_pass {
{{#include ../../../packages/samples/sources/move-basics/references.move:header}}

{{#include ../../../packages/samples/sources/move-basics/references.move:new}}
}
```

<!-- In [the previous section](./ownership-and-scope.md) we explained the ownership and scope in Move. We showed how the value is *moved* to a new scope, and how it changes the owner. In this section, we will explain how to *borrow* a reference to a value to avoid moving it, and how Move's *borrow checker* ensures that the references are used correctly. -->

## Reference

References are a way to _show_ a value to a function without giving up the ownership. In our case,
when we show the Card to the inspector, we don't want to give up the ownership of it, and we don't
allow them to spend the rides. We just want to allow _reading_ the value of the Card and prove its
ownership.

To do so, in the function signature, we use the `&` symbol to indicate that we are passing a
reference to the value, not the value itself.

```move
{{#include ../../../packages/samples/sources/move-basics/references.move:immutable}}
```

Now the function can't take the ownership of the card, and it can't spend the rides. But it can read
its value. Worth noting, that a signature like this makes it impossible to call the function without
a Card at all. This is an important property which allows the
[Capability Pattern](./../programmability/capability.md) which we will cover in the next chapters.

## Mutable Reference

In some cases, we want to allow the function to change the value of the Card. For example, when we
use the Card at the turnstile, we want to spend a ride. To implement it, we use the `&mut` keyword
in the function signature.

```move
{{#include ../../../packages/samples/sources/move-basics/references.move:mutable}}
```

As you can see in the function body, the `&mut` reference allows mutating the value, and the
function can spend the rides.

## Passing by Value

Lastly, let's give an illustration of what happens when we pass the value itself to the function. In
this case, the function takes the ownership of the value, and the original scope can no longer use
it. The owner of the Card can recycle it, and, hence, lose the ownership.

```move
{{#include ../../../packages/samples/sources/move-basics/references.move:move}}
```

In the `recycle` function, the Card is _taken by value_ and can be unpacked and destroyed. The
original scope can't use it anymore.

## Full Example

To illustrate the full flow of the application, let's put all the pieces together in a test.

```move
{{#include ../../../packages/samples/sources/move-basics/references.move:move_2024}}
```

<!-- ## Dereference and Copy -->

<!-- TODO: defer and copy, *& -->

<!-- ## Notes -->

<!--
    Move 2024 is great but it's better to show the example with explicit &t and &mut t
    ...and then say that the example could be rewritten with the new syntax


-->

<!-- ## Move 2024

Here's the test from this page written with the Move 2024 syntax:

```move
{{#include ../../../packages/samples/sources/move-basics/references.move:move_2024}}
```
-->
# Option

Option is a type that represents an optional value which may or may not exist. The concept of Option
in Move is borrowed from Rust, and it is a very useful primitive in Move. `Option` is defined in the
[Standard Library](./standard-library.md), and is defined as follows:

File: move-stdlib/source/option.move

```move
// File: move-stdlib/source/option.move
/// Abstraction of a value that may or may not be present.
struct Option<Element> has copy, drop, store {
    vec: vector<Element>
}
```

> The 'std::option' module is implicitly imported in every module, and you don't need to add an
> import.

The `Option` is a generic type which takes a type parameter `Element`. It has a single field `vec`
which is a `vector` of `Element`. Vector can have length 0 or 1, and this is used to represent the
presence or absence of a value.

Option type has two variants: `Some` and `None`. `Some` variant contains a value and `None` variant
represents the absence of a value. The `Option` type is used to represent the absence of a value in
a type-safe way, and it is used to avoid the need for empty or `undefined` values.

## In Practice

To showcase why Option type is necessary, let's look at an example. Consider an application which
takes a user input and stores it in a variable. Some fields are required, and some are optional. For
example, a user's middle name is optional. While we could use an empty string to represent the
absence of a middle name, it would require extra checks to differentiate between an empty string and
a missing middle name. Instead, we can use the `Option` type to represent the middle name.

```move
{{#include ../../../packages/samples/sources/move-basics/option.move:registry}}
```

In the example above, the `middle_name` field is of type `Option<String>`. This means that the
`middle_name` field can either contain a `String` value or be empty. This makes it clear that the
middle name is optional, and it avoids the need for extra checks to differentiate between an empty
string and a missing middle name.

## Using Option

To use the `Option` type, you need to import the `std::option` module and use the `Option` type. You
can then create an `Option` value using the `some` or `none` methods.

```move
{{#include ../../../packages/samples/sources/move-basics/option.move:usage}}
```
# Address Type

<!--

Chapter: Basic Syntax
Goal: Introduce the address type
Notes:
    - a special type
    - named addresses via the Move.toml
    - address literals
    - 0x2 is 0x0000000...02

Links:
    - address concept
    - transaction context
    - Move.toml
    - your first move

 -->

To represent [addresses](./../concepts/address.md), Move uses a special type called `address`. It is
a 32 byte value that can be used to represent any address on the blockchain. Addresses are used in
two syntax forms: hexadecimal addresses prefixed with `0x` and named addresses.

```move
{{#include ../../../packages/samples/sources/move-basics/address.move:address_literal}}
```

An address literal starts with the `@` symbol followed by a hexadecimal number or an identifier. The
hexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the
[Move.toml](./../concepts/manifest.md) file and replaced with the corresponding address by the
compiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.

## Conversion

Sui Framework offers a set of helper functions to work with addresses. Given that the address type
is a 32 byte value, it can be converted to a `u256` type and vice versa. It can also be converted to
and from a `vector<u8>` type.

Example: Convert an address to a `u256` type and back.

```move
{{#include ../../../packages/samples/sources/move-basics/address.move:to_u256}}
```

Example: Convert an address to a `vector<u8>` type and back.

```move
{{#include ../../../packages/samples/sources/move-basics/address.move:to_bytes}}
```

Example: Convert an address into a string.

```move
{{#include ../../../packages/samples/sources/move-basics/address.move:to_string}}
```

## Further reading

- [Address](/reference/primitive-types/address.html) in the Move Reference.
# Control Flow

<!--

Chapter: Basic Syntax
Goal: Introduce control flow statements.
Notes:
    - if/else is an expression
    - while () {} loop
    - continue and break
    - loop {}
    - infinite loop is possible but will lead to gas exhaustion
    - return keyword
    - if is an expression and as such requires a semicolon (!!!)

Links:
    - reference (control flow)
    - coding conventions (control flow)

 -->

Control flow statements are used to control the flow of execution in a program. They are used to
make decisions, to repeat a block of code, and to exit a block of code early. Move has the following
control flow statements (explained in detail below):

- [`if` and `if-else`](#conditional-statements) - making decisions on whether to execute a block of
  code
- [`loop` and `while` loops](#repeating-statements-with-loops) - repeating a block of code
- [`break` and `continue` statements](#exiting-a-loop-early) - exiting a loop early
- [`return`](#return) statement - exiting a function early

## Conditional Statements

The `if` expression is used to make decisions in a program. It evaluates a
[boolean expression](./expression.md#literals) and executes a block of code if the expression is
true. Paired with `else`, it can execute a different block of code if the expression is false.

The syntax for the `if` expression is:

```move
if (<bool_expression>) <expression>;
if (<bool_expression>) <expression> else <expression>;
```

Just like any other expression, `if` requires a semicolon, if there are other expressions following
it. The `else` keyword is optional, except for the case when the resulting value is assigned to a
variable. We will cover this below.

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:if_condition}}
```

Let's see how we can use `if` and `else` to assign a value to a variable:

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:if_else}}
```

Here we assign the value of the `if` expression to the variable `y`. If `x` is greater than 0, `y`
will be assigned the value 1, otherwise 0. The `else` block is necessary, because both branches must
return a value of the same type. If we omit the `else` block, the compiler will throw an error.

<!-- TODO: add an error -->

Conditional expressions are one of the most important control flow statements in Move. They can use
either user provided input or some already stored data to make decisions. In particular, they are
used in the [`assert!` macro](./assert-and-abort.md) to check if a condition is true, and if not, to
abort execution. We will get to it very soon!

## Repeating Statements with Loops

Loops are used to execute a block of code multiple times. Move has two built-in types of loops:
`loop` and `while`. In many cases they can be used interchangeably, but usually `while` is used when
the number of iterations is known in advance, and `loop` is used when the number of iterations is
not known in advance or there are multiple exit points.

Loops are helpful when dealing with collections, such as vectors, or when we want to repeat a block
of code until a certain condition is met. However, it is important to be careful with loops, as they
can lead to infinite loops, which can lead to gas exhaustion and the transaction being aborted.

## The `while` loop

The `while` statement is used to execute a block of code as long as a boolean expression is true.
Just like we've seen with `if`, the boolean expression is evaluated before each iteration of the
loop. Just like conditional statements, the `while` loop is an expression and requires a semicolon
if there are other expressions following it.

The syntax for the `while` loop is:

```move
while (<bool_expression>) { <expressions>; };
```

Here is an example of a `while` loop with a very simple condition:

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:while_loop}}
```

## Infinite `loop`

Now let's imagine a scenario where the boolean expression is always `true`. For example, if we
literally passed `true` to the `while` condition. As you might expect, this would create an infinite
loop, and this is almost what the `loop` statement works like.

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:infinite_while}}
```

An infinite `while`, or `while` without a condition, is a `loop`. The syntax for it is simple:

```move
loop { <expressions>; };
```

Let's rewrite the previous example using `loop` instead of `while`:

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:infinite_loop}}
```

<!-- TODO: that's a weak point lmao -->

Infinite loops on their own are not very useful in Move, since every operation in Move costs gas,
and an infinite loop will lead to gas exhaustion. However, they can be used in combination with
`break` and `continue` statements to create more complex loops.

## Exiting a Loop Early

As we already mentioned, infinite loops are rather useless on their own. And that's where we
introduce the `break` and `continue` statements. They are used to exit a loop early, and to skip the
rest of the current iteration, respectively.

Syntax for the `break` statement is (without a semicolon):

```move
break
```

The `break` statement is used to stop the execution of a loop and exit it early. It is often used in
combination with a conditional statement to exit the loop when a certain condition is met. To
illustrate this point, let's turn the infinite `loop` from the previous example into something that
looks and behaves more like a `while` loop:

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:break_loop}}
```

Almost identical to the `while` loop, right? The `break` statement is used to exit the loop when `x`
is 5. If we remove the `break` statement, the loop will run forever, just like the previous example.

## Skipping an Iteration

The `continue` statement is used to skip the rest of the current iteration and start the next one.
Similarly to `break`, it is used in combination with a conditional statement to skip the rest of the
iteration when a certain condition is met.

Syntax for the `continue` statement is (without a semicolon):

```move
continue
```

The example below skips odd numbers and prints only even numbers from 0 to 10:

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:continue_loop}}
```

`break` and `continue` statements can be used in both `while` and `loop` loops.

## Early Return

The `return` statement is used to exit a [function](./function.md) early and return a value. It is
often used in combination with a conditional statement to exit the function when a certain condition
is met. The syntax for the `return` statement is:

```move
return <expression>
```

Here is an example of a function that returns a value when a certain condition is met:

```move
{{#include ../../../packages/samples/sources/move-basics/control-flow.move:return_statement}}
```

Unlike in other languages, the `return` statement is not required for the last expression in a
function. The last expression in a function block is automatically returned. However, the `return`
statement is useful when we want to exit a function early if a certain condition is met.
# Importing Modules

<!--
    TODO: create a better example for:
        1. Importing a module in general
        2. Importing a member
        3. Importing multiple members
        4. Grouping imports
        5. Self keyword for groups
-->

<!--

Goals:
    - Show the import syntax
    - Local dependencies
    - External dependencies
    - Importing modules from other packages

 -->

Move achieves high modularity and code reuse by allowing module imports. Modules within the same
package can import each other, and a new package can depend on already existing packages and use
their modules too. This section will cover the basics of importing modules and how to use them in
your own code.

## Importing a Module

Modules defined in the same package can import each other. The `use` keyword is followed by the
module path, which consists of the package address (or alias) and the module name separated by `::`.

```move
// File: sources/module_one.move
{{#include ../../../packages/samples/sources/move-basics/importing-modules.move:module_one}}
```

Another module defined in the same package can import the first module using the `use` keyword.

```move
// File: sources/module_two.move
{{#include ../../../packages/samples/sources/move-basics/importing-modules.move:module_two}}
```

## Importing Members

You can also import specific members from a module. This is useful when you only need a single
function or a single type from a module. The syntax is the same as for importing a module, but you
add the member name after the module path.

```move
{{#include ../../../packages/samples/sources/move-basics/importing-modules.move:members}}
```

## Grouping Imports

Imports can be grouped into a single `use` statement using the curly braces `{}`. This is useful
when you need to import multiple members from the same module. Move allows grouping imports from the
same module and from the same package.

```move
{{#include ../../../packages/samples/sources/move-basics/importing-modules.move:grouped}}
```

Single function imports are less common in Move, since the function names can overlap and cause
confusion. A recommended practice is to import the entire module and use the module path to access
the function. Types have unique names and should be imported individually.

To import members and the module itself in the group import, you can use the `Self` keyword. The
`Self` keyword refers to the module itself and can be used to import the module and its members.

```move
{{#include ../../../packages/samples/sources/move-basics/importing-modules.move:self}}
```

## Resolving Name Conflicts

When importing multiple members from different modules, it is possible to have name conflicts. For
example, if you import two modules that both have a function with the same name, you will need to
use the module path to access the function. It is also possible to have modules with the same name
in different packages. To resolve the conflict and avoid ambiguity, Move offers the `as` keyword to
rename the imported member.

```move
{{#include ../../../packages/samples/sources/move-basics/importing-modules.move:conflict}}
```

## Adding an External Dependency

Every new package generated via the `sui` binary features a `Move.toml` file with a single
dependency on the _Sui Framework_ package. The Sui Framework depends on the _Standard Library_
package. And both of these packages are available in default configuration. Package dependencies are
defined in the [Package Manifest](./../concepts/manifest.md) as follows:

```toml
[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }
Local = { local = "../my_other_package" }
```

The `dependencies` section contains a list of package dependencies. The key is the name of the
package, and the value is either a git import table or a local path. The git import contains the URL
of the package, the subdirectory where the package is located, and the revision of the package. The
local path is a relative path to the package directory.

If a dependency is added to the `Move.toml` file, the compiler will automatically fetch (and later
refetch) the dependencies when building the package.

## Importing a Module from Another Package

Normally, packages define their addresses in the `[addresses]` section, so you can use the alias
instead of the address. For example, instead of `0x2::coin` module, you would use `sui::coin`. The
`sui` alias is defined in the Sui Framework package. Similarly, the `std` alias is defined in the
Standard Library package and can be used to access the standard library modules.

To import a module from another package, you use the `use` keyword followed by the module path. The
module path consists of the package address (or alias) and the module name separated by `::`.

```move
{{#include ../../../packages/samples/sources/move-basics/importing-modules.move:external}}
```
# Constants

<!--

Chapter: Basic Syntax
Goal: Introduce constants.
Notes:
    - constants are immutable
    - constants are private
    - start with a capital letter always
    - stored in the bytecode (but w/o a name)
    - mention standard for naming constants

Links:
    - next section (abort and assert)
    - coding conventions (constants)
    - constants (language reference)

 -->

Constants are immutable values that are defined at the module level. They often serve as a way to
give names to static values that are used throughout a module. For example, if there's a default
price for a product, you might define a constant for it. Constants are stored in the module's
bytecode, and each time they are used, the value is copied.

```move
{{#include ../../../packages/samples/sources/move-basics/constants.move:shop_price}}
```

## Naming Convention

Constants must start with a capital letter - this is enforced at the compiler level. For constants
used as a value, there's a convention to use uppercase letters and underscores to separate words.
It's a way to make constants stand out from other identifiers in the code. One exception is made for
[error constants](./assert-and-abort.md#assert-and-abort), which are written in ECamelCase.

```move
{{#include ../../../packages/samples/sources/move-basics/constants.move:naming}}
```

## Constants are Immutable

Constants can't be changed and assigned new values. They are part of the package bytecode, and
inherently immutable.

```move
module book::immutable_constants {
    const ITEM_PRICE: u64 = 100;

    // emits an error
    fun change_price() {
        ITEM_PRICE = 200;
    }
}
```

## Using Config Pattern

A common use case for an application is to define a set of constants that are used throughout the
codebase. But due to constants being private to the module, they can't be accessed from other
modules. One way to solve this is to define a "config" module that exports the constants.

```move
{{#include ../../../packages/samples/sources/move-basics/constants.move:config}}
```

This way other modules can import and read the constants, and the update process is simplified. If
the constants need to be changed, only the config module needs to be updated during the package
upgrade.

## Links

- [Constants](/reference/constants.html) in the Move Reference
- [Coding conventions for constants](./../guides/coding-conventions.md#constant)
